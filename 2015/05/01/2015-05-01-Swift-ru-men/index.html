<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Swift 入门 | CoderShmily&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="特色
苹果宣称 Swift 的特点是：快速、现代、安全、互动，而且明显优于 Objective-C 语言
可以使用现有的 Cocoa 和 Cocoa Touch 框架
Swift 取消了 Objective C 的指针及其他不安全访问的使用
舍弃 Objective C 早期应用 Smalltalk 的语法，全面改为句点表示法
提供了类似 Java 的名字空间(namespace)、泛型(gene">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 入门">
<meta property="og:url" content="http://codershmily.github.io/2015/05/01/2015-05-01-Swift-ru-men/index.html">
<meta property="og:site_name" content="CoderShmily's Blog">
<meta property="og:description" content="特色
苹果宣称 Swift 的特点是：快速、现代、安全、互动，而且明显优于 Objective-C 语言
可以使用现有的 Cocoa 和 Cocoa Touch 框架
Swift 取消了 Objective C 的指针及其他不安全访问的使用
舍弃 Objective C 早期应用 Smalltalk 的语法，全面改为句点表示法
提供了类似 Java 的名字空间(namespace)、泛型(gene">
<meta property="og:image" content="http://codershmily.github.io/images/2015-10-12-Swift开发/项目名-- 命名空间.png">
<meta property="og:updated_time" content="2015-10-14T09:25:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift 入门">
<meta name="twitter:description" content="特色
苹果宣称 Swift 的特点是：快速、现代、安全、互动，而且明显优于 Objective-C 语言
可以使用现有的 Cocoa 和 Cocoa Touch 框架
Swift 取消了 Objective C 的指针及其他不安全访问的使用
舍弃 Objective C 早期应用 Smalltalk 的语法，全面改为句点表示法
提供了类似 Java 的名字空间(namespace)、泛型(gene">
<meta name="twitter:image" content="http://codershmily.github.io/images/2015-10-12-Swift开发/项目名-- 命名空间.png">
  
    <link rel="alternate" href="/atom.xml" title="CoderShmily&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      
      <div class="outer">
        <section id="main"><article id="post-2015-05-01-Swift-ru-men" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/01/2015-05-01-Swift-ru-men/" class="article-date">
  <time datetime="2015-05-01T14:24:06.000Z" itemprop="datePublished">2015-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Swift/">Swift</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Swift 入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                <!-- Table of Contents -->
          
        <h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><ul>
<li>苹果宣称 Swift 的特点是：快速、现代、安全、互动，而且明显优于 Objective-C 语言</li>
<li>可以使用现有的 <code>Cocoa</code> 和 <code>Cocoa Touch</code> 框架</li>
<li>Swift 取消了 Objective C 的指针及其他不安全访问的使用</li>
<li>舍弃 Objective C 早期应用 <code>Smalltalk</code> 的语法，全面改为句点表示法</li>
<li>提供了类似 Java 的名字空间(namespace)、泛型(generic)、运算对象重载（operator overloading）</li>
<li>Swift 被简单的形容为 “没有 C 的 Objective-C”（Objective-C without the C）</li>
</ul>
<a id="more"></a>
<h1 id="常量-amp-变量"><a href="#常量-amp-变量" class="headerlink" title="常量&amp;变量"></a>常量&amp;变量</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">10</span></div><div class="line"><span class="built_in">print</span>(i)</div><div class="line">i = <span class="number">15</span></div><div class="line"><span class="built_in">print</span>(i)</div><div class="line"></div><div class="line"><span class="keyword">let</span> j = <span class="number">20</span></div></pre></td></tr></table></figure>
<ul>
<li>小结<ul>
<li><code>var</code> 定义变量，设置之后可以修改</li>
<li><code>let</code> 定义常量，设置之后不可以修改</li>
<li>语句末尾不用使用 <code>;</code></li>
<li>在 Swift 中使用 <code>print()</code> 替代 OC 中的 <code>NSLog</code></li>
<li><code>print</code> 的性能更好，后面会演示</li>
</ul>
</li>
</ul>
<h2 id="定义-OC-对象"><a href="#定义-OC-对象" class="headerlink" title="定义 OC 对象"></a>定义 <code>OC</code> 对象</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UIView *testView = [[UIView alloc] initWithFrame:];</span></div><div class="line"><span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</div><div class="line"></div><div class="line">testView.backgroundColor = <span class="type">UIColor</span>.redColor()</div><div class="line">view.addSubview(testView)</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">结构体:</div><div class="line">OC: CGPointMake()</div><div class="line">Swift: CGPoint()</div><div class="line">*/</div><div class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>(type: <span class="type">UIButtonType</span>.<span class="type">ContactAdd</span>)</div><div class="line">btn.center = <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">50</span>)</div><div class="line">view.addSubview(btn)</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li>在 <code>Swift</code> 中要实例化一个对象可以使用 <code>类名()</code> 的格式，与 <code>OC</code> 中的 <code>alloc/init</code> 等价</li>
<li><code>OC</code> 中的 <code>initWithXXX</code> 在 <code>Swift</code> 中通常可以使用 <code>类名(XXX: )</code> 找到对应的函数</li>
<li><code>OC</code> 中的 <code>[UIColor redColor]</code> 类方法，在 <code>Swift</code> 中通常可以使用 <code>类名.XXX</code> 找到对应的函数</li>
<li>使用 <code>let</code> 修饰 <code>v</code> 并且赋值，表示 <code>该常量的内存地址不允许修改，但是可以修改其内部的属性</code></li>
<li>当前对象的属性，不需要使用 <code>self.</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>常量&amp;变量的使用原则：尽量先用 let，只有需要变的时候，再用 var，能够更加安全</p>
</blockquote>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*:</span></div><div class="line">自动类型推导</div><div class="line">* 如果是在定义的同时初始化, 那么可以不用写数据类型, 编译器会根据右边的内容自动推导出当前的数据类型</div><div class="line">* 技巧: 在做Swift开发中会经常使用 option + click 查看文档</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> y = <span class="number">10.5</span></div><div class="line"><span class="keyword">var</span> z: <span class="type">Double</span> = <span class="number">20</span></div><div class="line"></div><div class="line"><span class="comment">// 注意: 在Swift中Double和CGFloat也是需要转换的</span></div><div class="line"><span class="built_in">print</span>(<span class="type">Double</span>(x) + y)</div><div class="line"><span class="built_in">print</span>(x + <span class="type">Int</span>(y))</div><div class="line"><span class="built_in">print</span>(y + z)</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li><code>Swift</code> 是对类型要求非常严格的一门语言，<code>一个值永远不会被自动转换成其他类型</code></li>
<li>如果要转换，必须显示转换，Swift 中<ul>
<li>小数默认是 <code>Double</code> 类型</li>
<li>整数默认是 <code>Int</code> 类型</li>
</ul>
</li>
<li>如果要显式的指定变量的类型，可以在定义是使用 <code>var 变量名: 类型 = 值</code><h1 id="逻辑分支"><a href="#逻辑分支" class="headerlink" title="逻辑分支"></a>逻辑分支</h1></li>
</ul>
</li>
</ul>
<h2 id="简单体验"><a href="#简单体验" class="headerlink" title="简单体验"></a>简单体验</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"OK"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li><code>Swift</code> 中没有 C 语言中的<code>非零即真</code>概念</li>
<li>在逻辑判断时必须显示地指明具体的判断条件</li>
<li><code>if</code> 语句条件的 <code>()</code> 可以省略</li>
<li>但是 <code>{}</code> 不能省略</li>
<li>Swift中提供了真正的Bool类型, true/false, 条件表达式的值必须是true/false</li>
</ul>
</li>
</ul>
<h2 id="三目"><a href="#三目" class="headerlink" title="三目"></a>三目</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> b = <span class="number">50</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> result = a &gt; b ? a : b</div><div class="line"><span class="built_in">print</span>(result)</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li><code>Swift</code> 中的 <code>三目</code> 运算保持了和 OC 一致的风格</li>
<li>注意: 运算符之间需要有空格</li>
<li>提醒: 在Swift开发中三目运算符用得非常多</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*:</span></div><div class="line">Switch</div><div class="line">* switch后面的圆括号可以省略</div><div class="line">* 如果是在OC中每个case后面不写break, 导致穿透. 而在Swift中不会</div><div class="line">* 如果是在OC中想在case后面定义变量, 必须加上&#123;&#125;说明作用域, 而在Swift中不用说明作用域</div><div class="line">* 如果是在OC中default的位置可以随便写, 而在Swift中不允许</div><div class="line">* 如果是在OC中default可以不用写, 而在Swift中大部分情况下是必须写的</div><div class="line">*/</div><div class="line"><span class="keyword">let</span> value = <span class="number">3</span></div><div class="line"><span class="keyword">switch</span> value</div><div class="line">&#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"0"</span>)</div><div class="line">    <span class="keyword">var</span> i = <span class="number">10</span></div><div class="line"><span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"other"</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><h3 id="演练-1"><a href="#演练-1" class="headerlink" title="演练 1"></a>演练 1</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"http://www.baidu.com/"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> url != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="type">NSURLSession</span>.sharedSession().dataTaskWithURL(url!, completionHandler: &#123; (data, <span class="number">_</span>, <span class="number">_</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">        <span class="built_in">print</span>(<span class="type">NSString</span>(data: data!, encoding: <span class="type">NSUTF8StringEncoding</span>))</div><div class="line">    &#125;).resume()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li>在 <code>Swift</code> 中，不是所有的对象实例化方法都会返回值，在实际开发中需要注意实例化函数的返回类型，例如：</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>?(string <span class="type">URLString</span>: <span class="type">String</span>)</div></pre></td></tr></table></figure>
<pre><code>* 如果有 `?` 表示该方法有可能无法实例化到正确的对象
* 这种函数返回的对象，被称为 `可选项`，即有可能有值，也有可能没有值
* 实际开发时，需要针对这种对象加以判断，并且在分支内部使用 `!`，指明改对象确实是存在的
* 相比在 `OC` 的开发，尤其在日常练习时，会给定一个能够运行的值，而在实际运行时，一旦条件不满足，会直接闪退，这样用户体验会非常不好
</code></pre><blockquote>
<p><code>Swift</code> 的设计者考虑到因为对类型的强制要求，会让代码很难看，因此提供了一个变通的解决方案</p>
</blockquote>
<h3 id="演练-2"><a href="#演练-2" class="headerlink" title="演练 2"></a>演练 2</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"http://www.baidu.com"</span>) &#123;</div><div class="line">    <span class="type">NSURLSession</span>.sharedSession().dataTaskWithURL(url, completionHandler: &#123; (data, <span class="number">_</span>, <span class="number">_</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">        <span class="built_in">print</span>(<span class="type">NSString</span>(data: data!, encoding: <span class="type">NSUTF8StringEncoding</span>))</div><div class="line">    &#125;).resume()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>阶段性小结</p>
<ul>
<li>使用 <code>if let 常量 = 可选构造函数</code> 的方式能够确保分支内部常量一定是有值的</li>
<li>并且在分支内部不再需要使用 <code>!</code></li>
<li>这是 <code>Swift</code> 代码中的一个非常重要的使用技巧</li>
</ul>
</li>
<li><p>提示</p>
<ul>
<li>尽管 <code>Swift</code> 提供了类型校验的手段，但是要写出 <code>优雅</code> 的 Swift 代码，还是需要多加练习的，否则一不小心就会出现分支嵌套层次很深的代码</li>
<li>有关 <code>?</code> 和 <code>!</code> 的选择，可以借助 Xcode 的辅助工具，但是强烈建议每次遇到提示时，要多加思考，反复揣摩</li>
</ul>
</li>
</ul>
<h3 id="演练3"><a href="#演练3" class="headerlink" title="演练3"></a>演练3</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line"><span class="built_in">print</span>(name?.lengthOfBytesUsingEncoding(<span class="type">NSUTF8StringEncoding</span>))</div><div class="line"></div><div class="line"><span class="comment">//name = "lnj"</span></div><div class="line"><span class="built_in">print</span>(name?.lengthOfBytesUsingEncoding(<span class="type">NSUTF8StringEncoding</span>))</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">print</span>((name?.lengthOfBytesUsingEncoding(<span class="type">NSUTF8StringEncoding</span>) ?? <span class="number">0</span>))</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li><code>??</code> 是一个非常有用的操作符，能够快速对 <code>nil</code> 进行判断</li>
<li>如果对象是 <code>nil</code>，则使用 <code>??</code> 后面的值代替前面的 <code>nil</code> 值参与计算</li>
<li>在使用 <code>??</code> 时，整个部分需要使用 <code>()</code> 包装</li>
<li>这一技巧在 <code>UITableView</code> 的数据源方法中尤为重要</li>
</ul>
</li>
</ul>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="OC风格的-for"><a href="#OC风格的-for" class="headerlink" title="OC风格的 for"></a>OC风格的 <code>for</code></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 传统写法</span></div><div class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">    <span class="built_in">print</span>(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Swift风格的-for"><a href="#Swift风格的-for" class="headerlink" title="Swift风格的 for"></a>Swift风格的 <code>for</code></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历 0 ~ &lt;10</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</div><div class="line">    <span class="built_in">print</span>(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"---"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 遍历 0 ~ 10</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123;</div><div class="line">    <span class="built_in">print</span>(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li><code>Swift</code> 中使用 <code>in</code> 关键字标示循环的范围</li>
<li><code>0..&lt;10</code> 表示从0到9</li>
<li><code>0...10</code> 表示从0到10</li>
<li>注意之间不能出现空格</li>
</ul>
</li>
</ul>
<h2 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li>如果不关心循环本身的索引，可以使用 <code>_</code> 忽略</li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组中保存的对象类型"><a href="#数组中保存的对象类型" class="headerlink" title="数组中保存的对象类型"></a>数组中保存的对象类型</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组中保存的都是字符串</span></div><div class="line"><span class="keyword">let</span> arr = [<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>]</div><div class="line"></div><div class="line"><span class="comment">// 特点: 自动将基本数据类型转换为对象类型</span></div><div class="line"><span class="keyword">let</span> arr1 = [<span class="string">"zhangsan"</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li>数组使用 [] 定义，这一点与 OC 相同</li>
<li>如果初始化时，所有内容类型一致，择数组中保存的是该类型的内容</li>
<li>如果初始化时，所有内容类型不一致，择数组中保存的是 <code>NSObject</code></li>
</ul>
</li>
</ul>
<h2 id="常见数组操作"><a href="#常见数组操作" class="headerlink" title="常见数组操作"></a>常见数组操作</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义只能保存字符串类型数组</span></div><div class="line">var array: [String]</div><div class="line"><span class="comment">// 初始化数组</span></div><div class="line">array = [<span class="string">"zhangsan"</span>]</div><div class="line"></div><div class="line"><span class="meta"># 实例化新的数组</span></div><div class="line"><span class="comment">// 实例化一个空数组</span></div><div class="line">var array2 = [String]()</div><div class="line"><span class="comment">// var array2:[String] = []</span></div><div class="line">array2.append(<span class="string">"1"</span>)</div><div class="line">array2.append(<span class="string">"2"</span>)</div><div class="line"></div><div class="line"><span class="meta"># 添加元素</span></div><div class="line">array.append(<span class="string">"lisi"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta"># 删除元素</span></div><div class="line"><span class="comment">// 删除, 数组的删除方法会将被删除的元素返回给我们</span></div><div class="line">array.removeAtIndex(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="meta"># 删除所有元素</span></div><div class="line"><span class="comment">// keepCapacity: 删除数组中的元素, 是否需要保持数组原有的容量, 如果传入false代表不保持容量</span></div><div class="line">array.removeAll(keepCapacity: <span class="literal">true</span>)</div><div class="line">print(array.capacity)</div><div class="line"></div><div class="line"><span class="comment">// 注意数组容量的变化</span></div><div class="line"><span class="comment">// 注意点: 数组添加容量永远是在原有容量的基础上*2</span></div><div class="line"><span class="comment">// 放得下继续放,放不下时,在此时的capacity * 2</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">10</span> &#123;</div><div class="line">    array.append(<span class="string">"\(i)"</span>)</div><div class="line">    print(<span class="string">"\(array) --- \(array.capacity)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta"># 拼接数组 数组类型要相同</span></div><div class="line">array += array2</div><div class="line"></div><div class="line"><span class="meta"># 遍历</span></div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> arr &#123;</div><div class="line">    print(a)</div><div class="line">    <span class="comment">// 像 OC 一样打印</span></div><div class="line">    <span class="comment">// print(arr as NSArray)</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li>如果定义数组时指定了保存对象的类型，则不能向数组中添加其他类型的内容</li>
<li>可以使用 <code>[String]()</code></li>
<li><code>let</code> 定义的数组是<code>不可变的</code></li>
<li><code>var</code> 定义的数组是<code>可变的</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">字典</div><div class="line">* OC @&#123;key:value&#125;</div><div class="line">* Swift [key:value]</div><div class="line">* 和数组一样, 如果用let修饰就是不可变字典, 如果用var修饰就是可变字典</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">// 开发技巧: 在iOS开发中使用频率最高的就是 [String: AnyObject]</span></div><div class="line">let dict1 = [<span class="string">"name"</span>: <span class="string">"lnj"</span>, <span class="string">"age"</span>: <span class="number">3</span>]</div><div class="line"></div><div class="line">var dict2:[String: AnyObject]</div><div class="line">dict2 = [<span class="string">"name"</span>: <span class="string">"lnj"</span>, <span class="string">"age"</span>: <span class="number">3</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta"># 获取</span></div><div class="line"><span class="comment">// 注意点: 从字典中取出的值都是可选类型的值</span></div><div class="line"><span class="comment">// 因为通过一个key取值, 可能取得到, 也可能取不到, 所以返回一个可选类型的值</span></div><div class="line"><span class="comment">// 如果!写在[]后面, 代表取出来的值一定有值</span></div><div class="line"><span class="comment">// 如果!写在dict后面, 代表dict一定有值</span></div><div class="line">print(dict2[<span class="string">"name"</span>]!)</div><div class="line"></div><div class="line"><span class="meta"># 更新</span></div><div class="line">dict2[<span class="string">"name"</span>] = <span class="string">"zs"</span></div><div class="line">dict2</div><div class="line"></div><div class="line"><span class="meta"># 添加</span></div><div class="line"><span class="comment">// 也就是说, 如果key存在就是更新, 如果key不存在就是添加</span></div><div class="line">dict2[<span class="string">"score"</span>] = <span class="number">99</span></div><div class="line">dict2</div><div class="line"></div><div class="line"><span class="meta"># 遍历</span></div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict2.keys</div><div class="line">&#123;</div><div class="line">    print(dict2[key])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 会将字典中的key赋值给()中的第一个变量k</span></div><div class="line"><span class="comment">// 会将字典中的value赋值给()中的第二个变量v</span></div><div class="line"><span class="comment">// 注意: k/v随便写</span></div><div class="line"></div><div class="line"><span class="comment">// ()括起来的东西我们称之为元祖, 元祖是Swift中新增的一种数据类型</span></div><div class="line"><span class="keyword">for</span> (x, o) <span class="keyword">in</span> dict2</div><div class="line">&#123;</div><div class="line">    print(x)</div><div class="line">    print(o)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta"># 合并</span></div><div class="line"></div><div class="line">var dict3:[String: AnyObject] = [<span class="string">"name"</span>: <span class="string">"lnj"</span>, <span class="string">"age"</span>: <span class="number">3</span>]</div><div class="line">var dict4:[String: AnyObject] = [<span class="string">"score"</span>: <span class="number">99</span>]</div><div class="line"><span class="comment">// 字典不能像数组一样通过+=来合并</span></div><div class="line"><span class="comment">//dict3 += dict4</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> dict3</div><div class="line">&#123;</div><div class="line"><span class="comment">// 要在声明时统一字典的格式,不然报错</span></div><div class="line"><span class="comment">// 因为如果不加[String: AnyObject],dict3默认是此类型,</span></div><div class="line"><span class="comment">// dict4默认是[String: Int],不能把AnyObject给Int赋值</span></div><div class="line">    dict4[k] = v</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote>
<p>在 Swift 中绝大多数的情况下，推荐使用 String 类型</p>
</blockquote>
<h2 id="使用-String-的原因"><a href="#使用-String-的原因" class="headerlink" title="使用 String 的原因"></a>使用 <code>String</code> 的原因</h2><ul>
<li><code>String</code> 是一个结构体，性能更高<ul>
<li><code>String</code> 目前具有了绝大多数 NSString 的功能</li>
<li><code>String</code> 支持直接遍历</li>
</ul>
</li>
<li><code>NSString</code> 是一个 <code>OC</code> 对象，性能略差</li>
<li><code>Swift</code> 提供了 <code>String</code> 和 <code>NSString</code> 之间的无缝转换</li>
</ul>
<h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">"我要飞的更High"</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> s <span class="keyword">in</span> str.characters &#123;</div><div class="line">    <span class="built_in">print</span>(s)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str1 = <span class="string">"zhangsan"</span></div><div class="line"><span class="keyword">let</span> str2 = <span class="string">"lisi"</span></div><div class="line"><span class="keyword">let</span> i = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="comment">// 注意: Swift的print函数不支持%i/%@等占位符</span></div><div class="line"><span class="comment">// Swift中拼接内容使用 \(需要拼接的数据)</span></div><div class="line"><span class="built_in">print</span>(str1 + str2)</div><div class="line"><span class="built_in">print</span>(<span class="string">"\(str1) \(str2) \(i)"</span>)</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li>直接在 <code>&quot;&quot;</code> 中使用 <code>\(变量名)</code> 的方式可以快速拼接字符串</li>
<li>小伙伴们再也不要考虑 <code>stringWithFormat</code> 了</li>
</ul>
</li>
</ul>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123;</div><div class="line">    <span class="keyword">let</span> str = <span class="type">String</span>(format: <span class="string">"zhangsan - %04d"</span>, arguments: [arc4random_uniform(<span class="number">100</span>)])</div><div class="line">    <span class="built_in">print</span>(str)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 15-09-07</span></div><div class="line"><span class="keyword">let</span> res2 = <span class="type">String</span>(format: <span class="string">"%02d-%02d-%02d"</span>, arguments: [<span class="number">15</span>, <span class="number">9</span>, <span class="number">7</span>])</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li>在实际开发中，如果需要指定字符串格式，可以使用 <code>String(format:...)</code> 的方式</li>
<li>注意：后面的参数需要放在一个数组中</li>
</ul>
</li>
</ul>
<h2 id="String-amp-Range-的结合"><a href="#String-amp-Range-的结合" class="headerlink" title="String &amp; Range 的结合"></a>String &amp; Range 的结合</h2><blockquote>
<p>以下是超级费劲的代码</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str: <span class="type">String</span> = <span class="string">"xiaomage"</span></div><div class="line"></div><div class="line"><span class="comment">// 没写完整,很麻烦</span></div><div class="line"><span class="keyword">var</span> subStr = str.substringWithRange(<span class="type">Range</span>&lt;<span class="type">String</span>.<span class="type">Index</span>&gt;(start: str.startIndex, end: str.endIndex))</div><div class="line"><span class="built_in">print</span>(subStr)</div></pre></td></tr></table></figure>
<h3 id="建议写法"><a href="#建议写法" class="headerlink" title="建议写法"></a>建议写法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 建议: 在Swift开发中如果要截取字符串,</span></div><div class="line"><span class="comment">// 或者以前在OC中使用的方法在Swift字符串中没有,</span></div><div class="line"><span class="comment">// 建议先将Swift字符串转换为OC字符串之后再使用</span></div><div class="line"><span class="keyword">let</span> str1: <span class="type">NSString</span> = <span class="string">"xiaomage"</span></div><div class="line"><span class="comment">//let str3 = str2 as NSString</span></div><div class="line"><span class="comment">//let str3: NSString = str2</span></div><div class="line"><span class="built_in">print</span>(str1.substringWithRange(<span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>)))</div><div class="line"></div><div class="line"><span class="keyword">let</span> str5:<span class="type">NSString</span> = <span class="string">"user/desktop/abc.txt"</span></div><div class="line">str5.pathExtension</div></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="简单演练"><a href="#简单演练" class="headerlink" title="简单演练"></a>简单演练</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>阶段性小结<ul>
<li>函数定义格式：<code>func 函数名(参数: 参数类型...) -&gt; 返回值 { // 代码实现 }</code></li>
<li>如果没有返回值， <code>-&gt; 返回值</code> 可以省略</li>
<li><code>-&gt;</code> 是一个很有意思的符号</li>
<li>默认情况下，在调用函数时，第一个参数名是省略的</li>
</ul>
</li>
</ul>
<h2 id="参数名的特殊处理"><a href="#参数名的特殊处理" class="headerlink" title="参数名的特殊处理"></a>参数名的特殊处理</h2><h3 id="强制要求参数名"><a href="#强制要求参数名" class="headerlink" title="强制要求参数名"></a>强制要求参数名</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x,y函数调用的时候显示sum1(x: 10, y: 10)</span></div><div class="line"><span class="comment">// a,b函数内部使用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum1</span><span class="params">(x a: Int, y b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="省略参数名"><a href="#省略参数名" class="headerlink" title="省略参数名"></a>省略参数名</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不加_调用函数sum1(10, b: 10)</span></div><div class="line"><span class="comment">// 加了后调用sum(10,10)</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum2</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#没有返回值没有参数的</span></div><div class="line">func say() -&gt; Void</div><div class="line">&#123;&#125;</div><div class="line">say()</div><div class="line"></div><div class="line"><span class="meta">#如果没有返回值还可以简写</span></div><div class="line"><span class="comment">// Void == ()</span></div><div class="line">func say2() -&gt; ()</div><div class="line">&#123;&#125;</div><div class="line"></div><div class="line"><span class="meta"># 如果没有返回值, 那么返回值类型可以省略</span></div><div class="line">func say3()</div><div class="line">&#123;&#125;</div><div class="line"></div><div class="line"><span class="meta"># 有返回值没有参数的</span></div><div class="line"><span class="comment">// 注意点: 返回值类型必须和返回的值保持一致</span></div><div class="line">func getMax() -&gt;Int</div><div class="line">&#123;&#125;</div><div class="line"></div><div class="line"><span class="meta"># 没有返回值有参数的</span></div><div class="line"><span class="comment">// 从Swift2.0开始, 会自动将第二个参数开始的参数名称作为方法的标签</span></div><div class="line">func sum(a: Int, b: Int)</div><div class="line">&#123;</div><div class="line">    print(<span class="string">"sum = \(a + b)"</span>)</div><div class="line">&#125;</div><div class="line">sum(<span class="number">10</span>, b: <span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="meta"># 有返回值有参数的</span></div><div class="line">func sum5(a: Int, b: Int) -&gt; Int</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta"># 已经弃用,代表a/b既是内部参数也是外部参数</span></div><div class="line">func sum(<span class="meta">#a: Int, #b: Int)</span></div><div class="line">&#123;</div><div class="line">    print(<span class="string">"sum = \(a + b)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta"># 默认值</span></div><div class="line"><span class="comment">// 如果指定了默认值, 那么调用的时候可以忽略, 如果忽略会使用默认值</span></div><div class="line"><span class="comment">// 在其它语言中其实早就有默认值的概念了, 在其它语言中的默认值只能写在形参列表的最后面</span></div><div class="line"><span class="comment">// 但是Swift中的默认值可以写在任意地方</span></div><div class="line">func sum3(a: Int, b: Int = <span class="number">110</span>)</div><div class="line">&#123;</div><div class="line">    print(<span class="string">"sum = \(a  + b)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h4 id="闭包和OC中的Block差不多"><a href="#闭包和OC中的Block差不多" class="headerlink" title="闭包和OC中的Block差不多"></a>闭包和OC中的Block差不多</h4><p>1.都是用来保存一段代码, 在适当的时候执行</p>
<p>2.一般用于做一些耗时操作</p>
<p>3.传递值<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">类型的格式:  (形参列表)-&gt;返回值类型</div><div class="line"><span class="keyword">in</span>的作用就是用于分隔需要执行的代码</div><div class="line">值的格式: </div><div class="line">&#123;</div><div class="line">    (形参列表)-&gt;返回值类型</div><div class="line">    <span class="keyword">in</span></div><div class="line">    需要执行的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>闭包和Block的区别:</p>
<ul>
<li>Block类似于匿名函数</li>
<li>闭包就是用来定义函数的, Swift中函数其实就是闭包</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//    注意: 以下写法是错误的, 代表闭包的返回值是可选的</span></div><div class="line"><span class="comment">/*    var finished: ()-&gt;()? */</span></div><div class="line">正解:    <span class="keyword">var</span> finished: (()-&gt;())?</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 简写:</span></div><div class="line">func loadData(finished: ()-&gt;())</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 1.执行耗时操作</span></div><div class="line">    print(<span class="string">"耗时操作"</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 2.回调通知调用者执行完毕</span></div><div class="line">    finished()</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">简写:</div><div class="line">1.如果闭包没有参数, 并且没有返回值, 那么in和in之前的代码可以省略</div><div class="line">2.如故偶闭包是形参列表的最后一个参数, 那么可以将闭包写到圆括号后面</div><div class="line">3.如果形参列表只有一个参数, 并且这个参数是闭包, 那么圆括号可以省略</div><div class="line">*/</div><div class="line">loadData &#123;</div><div class="line">    print(<span class="string">"收到执行完毕的通知"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">loadData &#123;</div><div class="line"><span class="meta"># 如果在闭包中使用到了外界对象, 必须加上self</span></div><div class="line"><span class="comment">// self.view.backgroundColor = UIColor.redColor()</span></div><div class="line">    weakSelf!.view.backgroundColor = <span class="built_in">UIColor</span>.redColor()</div><div class="line">&#125;</div><div class="line"></div><div class="line">loadData &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; () <span class="keyword">in</span></div><div class="line">    print(<span class="string">"收到执行完毕的通知"</span>)</div><div class="line">    <span class="keyword">self</span>!.view.backgroundColor = <span class="built_in">UIColor</span>.redColor()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Swift中推荐能不写self就不写self,  </span></div><div class="line"></div><div class="line"><span class="comment">// OC中weak特点: 如果对象被释放之后会自动赋值给nil</span></div><div class="line"><span class="comment">// OC中的__unsafe_unretained特点: 如果对象被释放之后不会自动赋值为nil</span></div><div class="line"><span class="comment">// unowned 相当于OC中的__unsafe_unretained, 并且特点一致</span></div><div class="line">loadData &#123; [unowned <span class="keyword">self</span>] () -&gt; () <span class="keyword">in</span></div><div class="line">    print(<span class="string">"收到执行完毕的通知"</span>)</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = <span class="built_in">UIColor</span>.redColor()</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func loadData(finished: ()-&gt;())</div><div class="line">&#123;</div><div class="line"><span class="comment">// 0.保存闭包</span></div><div class="line">over = finished</div><div class="line"></div><div class="line"><span class="comment">// 1.执行耗时操作</span></div><div class="line">print(<span class="string">"耗时操作"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 2.回调通知调用者执行完毕</span></div><div class="line">finished()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 相当于OC中的dealloc方法, 对象释放的时候就会调用该方法</span></div><div class="line"><span class="comment">// 在这个方法中主要进行一些资源的释放操作</span></div><div class="line">deinit&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><ul>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lazy var 变量: 类型 = &#123; 创建变量代码 &#125;()</div></pre></td></tr></table></figure>
<ul>
<li>懒加载的写法本质上是定义并执行一个闭包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 含义: 当dataList被使用到时, 就会执行等号后面的闭包</div><div class="line">// 所以等号后面的闭包的()是必须写的, 如果不写就会报错</div><div class="line">// 注意点: 如果写懒加载, 那么修饰符必须用var</div><div class="line">lazy var dataList:[String] = &#123;</div><div class="line">    print(&quot;我被加载了&quot;)</div><div class="line">    return [&quot;lnj&quot;, &quot;lmj&quot;, &quot;zs&quot;]</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lazy var satatuses: [String] = self.loadStatus()</div><div class="line">func loadStatus() -&gt; [String]</div><div class="line">&#123;</div><div class="line">    print(&quot;我被加载了&quot;)</div><div class="line">    return [&quot;lnj&quot;, &quot;lmj&quot;, &quot;zs&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Swift中如果文件在同一个命名空间下是不需要导入头文件的</div><div class="line">同一个命名空间可以理解为同一个工程</div><div class="line">默认情况下, 项目名称就是命名空间的名称,如果想要修改命名空间可以在详见截图</div></pre></td></tr></table></figure>
<p><img src="/images/2015-10-12-Swift开发/项目名-- 命名空间.png" alt="项目名-命名空间"> </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _name: <span class="type">String</span>?</div><div class="line"><span class="keyword">var</span> name: <span class="type">String</span>?&#123;</div><div class="line">    <span class="keyword">get</span>&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"get"</span>)</div><div class="line">        <span class="keyword">return</span> _name</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span>&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"set"</span>)</div><div class="line">        <span class="comment">// newValue是系统提供给我们的, 只要重写set方法, 就可以通过newValue拿到外界设置的值</span></div><div class="line">        _name = newValue</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">didSet</span>&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>)</div><div class="line">        <span class="comment">// 设置完毕之后就会调用</span></div><div class="line">        name = <span class="string">"cool"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算属性, 计算属性不具备存储功能</span></div><div class="line"><span class="keyword">var</span> age: <span class="type">Int</span>?&#123;</div><div class="line">    <span class="keyword">get</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">100</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h1><h2 id="自定义-Person-类"><a href="#自定义-Person-类" class="headerlink" title="自定义 Person 类"></a>自定义 Person 类</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="getter-amp-setter"><a href="#getter-amp-setter" class="headerlink" title="getter &amp; setter"></a>getter &amp; setter</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _name: <span class="type">String</span>?</div><div class="line"></div><div class="line"><span class="keyword">var</span> name: <span class="type">String</span>? &#123;</div><div class="line">    <span class="keyword">get</span> &#123;</div><div class="line">        <span class="keyword">return</span> _name</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span> &#123;</div><div class="line">        _name = newValue</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在 <code>Swift</code> 中以上形式的 getter &amp; setter 很少用</li>
</ul>
<h2 id="didSet"><a href="#didSet" class="headerlink" title="didSet"></a>didSet</h2><ul>
<li>在 OC 中，我们通常希望在给某一个变量赋值之后，去做一些额外的操作</li>
<li>最经典的应用就是在自定义 Cell 的时候，通过模型的设置方法完成 Cell 的填充</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> length: <span class="type">Int</span>? &#123;</div><div class="line">    <span class="keyword">didSet</span> &#123;</div><div class="line">        timeStr = <span class="type">String</span>(format: <span class="string">"%02d:%02d:%02d"</span>, arguments: [length! / <span class="number">3600</span>, (length! % <span class="number">3600</span>) / <span class="number">60</span>, length! % <span class="number">60</span>])</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> timeStr: <span class="type">String</span>?</div></pre></td></tr></table></figure>
<h2 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> title: <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">get</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Mr "</span> + (name ?? <span class="string">""</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>只实现 <code>getter</code> 方法的属性被称为计算型属性，等同于 OC 中的 <code>ReadOnly</code> 属性</li>
<li>计算型属性本身不占用内存空间</li>
<li>不可以给计算型属性设置数值</li>
<li>计算型属性可以使用以下代码简写</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> title: <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Mr "</span> + (name ?? <span class="string">""</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>注意点: 如果没有在构造方法中对属性进行初始化,<br>那么对象类型可以写?,<code>基本数据类型最好直接赋值一个初始值</code></p>
<p>如果在构造方法中给属性赋了初始值, 那么就可以不用写?了,因为只要创建对象就一定会调用构造<br>方法, 只要调用构造方法那么属性就一定有值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在Swift中, 如果重写父类的方法, 需要加上override修饰</span></div><div class="line">override init() &#123;</div><div class="line">    name = <span class="string">"lnj"</span></div><div class="line">    age = <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 自定义构造方法</span></div><div class="line"><span class="comment">// 只要自定义了构造方法, 那么系统自带的默认构造方法就会失效</span></div><div class="line">init(name: String, age: Int)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//        注意: Swift语法规定, 一定要初始化完当前类之后才能初始化父类</span></div><div class="line">    <span class="keyword">self</span>.name = name</div><div class="line">    <span class="keyword">self</span>.age = age</div><div class="line">    <span class="comment">// 注意: 系统悄悄的帮我们调用了一次super.init()</span></div><div class="line"><span class="meta"># 因为默认的init没了,所以创建对象要用默认的init(),要override init</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 传入字典构造对象</span></div><div class="line"><span class="keyword">init</span>(dict: [<span class="type">NSObject</span>: <span class="type">AnyObject</span>]) &#123;</div><div class="line">    name = dict[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">    age = dict[<span class="string">"age"</span>] <span class="keyword">as</span>? <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">init</span>(dict:[<span class="type">String</span>: <span class="type">AnyObject</span>])</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 注意: 在构造方法中使用KVC必须先调用super.init()之后才能使用</span></div><div class="line">    <span class="comment">// 只有调用了super.init系统才会为属性分配存储空间</span></div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">    </div><div class="line">    <span class="comment">// 特点: 字典的key必须和模型的属性一一对应</span></div><div class="line">    setValuesForKeysWithDictionary(dict)</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// 利用KVC赋值时, 只要找不到对应的key就会调用这个属性</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">(value: AnyObject?, forUndefinedKey key: String)</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 相当于OC中的dealloc方法, 对象释放的时候就会调用该方法,</span></div><div class="line"><span class="comment">// 这个方法中主要进行一些资源的释放操作</span></div><div class="line"><span class="keyword">deinit</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"88"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重写description"><a href="#重写description" class="headerlink" title="重写description"></a>重写description</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重写打印对象属性</span></div><div class="line"><span class="comment">// 如果是计算型的属性, 可以简写</span></div><div class="line"><span class="keyword">let</span> properties = [<span class="string">"name"</span>, <span class="string">"age"</span>]</div><div class="line"><span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span>&#123;</div><div class="line"><span class="comment">//        return "name = \(name), age = \(age)"</span></div><div class="line">   <span class="keyword">let</span> dict = dictionaryWithValuesForKeys(properties)</div><div class="line">   <span class="keyword">return</span> <span class="string">"\(dict)"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.笨写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class NetworkTools: NSObject &#123;</div><div class="line">// USB写法</div><div class="line">static var onceToken: dispatch_once_t = 0</div><div class="line">static var instance: NetworkTools?</div><div class="line"></div><div class="line">//    func 相当于OC中的 -</div><div class="line">//    class func 相当于OC中的 +</div><div class="line">class func shareNetworkTools() -&gt; NetworkTools</div><div class="line">&#123;</div><div class="line">    print(&quot;onceToken = \(onceToken)&quot;)</div><div class="line">    dispatch_once(&amp;onceToken) &#123; () -&gt; Void in</div><div class="line">        print(&quot;我被调用了&quot;)</div><div class="line">        instance = NetworkTools()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return instance!</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.标准写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class NetworkTools: NSObject &#123;</div><div class="line">    // 这样写也是懒加载的</div><div class="line">    // 注意: 一定要写let, let本身就是线程安全的, 并且只能赋值一次</div><div class="line">    static let instance: NetworkTools = NetworkTools()</div><div class="line">    class func shareNetworkTools() -&gt; NetworkTools</div><div class="line">    &#123;</div><div class="line">        return instance</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://codershmily.github.io/2015/05/01/2015-05-01-Swift-ru-men/" data-id="cj11z9je00003uczjkaylomwn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/05/02/2015-05-02-singleton/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          单例模式的ARC和MRC实现
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/15/2016-11-15-Swift3.0-jie-shao/">Swift3.0学习笔记</a>
          </li>
        
          <li>
            <a href="/2015/05/15/2015-05-15-sdwebimageyuan-ma-jie-xi/">SDWebImage源码解析</a>
          </li>
        
          <li>
            <a href="/2015/05/07/2015-05-07-objective-c-runtime-si-dong-tai-fang-fa-jue-yi-dynamic-method-resolution/">Objective-C Runtime(四) 动态方法决议</a>
          </li>
        
          <li>
            <a href="/2015/05/06/2015-05-06-objective-c-runtime-san-xiao-xi-chuan-di/">Objective-C Runtime(三) 消息传递</a>
          </li>
        
          <li>
            <a href="/2015/05/05/2015-05-05-runtime-gai-shu/">Objective-C Runtime(一) 概述</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 CoderShmily<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>